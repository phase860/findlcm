## Программа для поиска наименьшего общего кратного чисел

Собрать:

> $ make

Будет скомпилирован исполняемый файл main.


Входные данные берутся из stdin, это целые числа, больше нуля, по числу на 
каждой новой строке.

Выходные данные поступают на stdout. Выводится наименьшее общее кратное в виде
его разложения на простые множители. 

Пример:

Для одного числа на выходе получаем разложение этого числа на простые множители.

> $ echo 6 | ./main

> 2 3


Наименьшее общее кратное для 6 и 4 это 12 = 2\*2\*3:

> $ echo 6 4 | ./main

> 2 2 3


Обработать данные из файла:

> $ ./main < test.txt

> ... 


При вводе отрицательного числа, нуля, символа отличного от цифры и числа больше,
чем INT_MAX - прогамма выбрасывает исключение и корректно завершается. Для 
входного значения 1 не выводится ничего.



### Структура приложения

Для разложения числа на простые множители применен простейший алгоритм 
перебора делителей (https://en.wikipedia.org/wiki/Trial_division). По условию 
задания входные числа по значению не превышают 10 000, для таких небольших
чисел данный алгоритм оказался достаточно быстрым.

Организована программа следующим образом. Создается объект класса  ThreadPool,
который, в свою очередь, создает n  объектов класса Worker. Worker в конструкторе
запускает поток, который спит, пока не появятся данные для обработки. Когда 
данные появляются, поток просыпается, обрабатывает их и засыпает, пока не 
появятся новые данные. Если Worker получает на вход специальное значение, то 
поток закачивает работу и Worker готов отдать ответ в виде std::map (какое 
простое число было в какой максимальной степени).

Синхронизация потоков осуществляется посредством шаблонного класса 
MsgManager. Один общий объект MsgManager создается классом ThreadPool и 
передается всем Worker-ам. Методы send и receive блокирующие, с буфером в одно
сообщение. Реализовано на двух условных переменных (и двух мьютексах к ним).
Может работать со множеством отправителей и получателей. 

Блокирующий send позволяет притормозить отправителя, если поток данных слишком 
быстрый и большой.


### Оптимизации

В качестве сообщения с заданием на обработку мы отправляем вектор, содержащий
1000 чисел (подобрано экспериментально). Обработка довольно быстрая (для чисел, 
которые имеющийся алгоритм может обработать быстро), загрузка сразу пакета 
заданий позволяет программе на 5 потоков (включая поток управления) полностью 
загрузить 4 ядра процессора. 

Задача на поиск НОК позволяет обрабатывать только первое вхождение числа, а 
последующие числа с тем же значением не обрабатывать. Это уже дает возможность
использовать set, чтобы фильтровать повторяющиеся значения. Но условие задания 
еще более ограничивает вход - числа не превышают 10000. Используя массив
мы можем находить повторное вхождение числа за O(1) операций.

Использование небуферизированного, потоконебезопасного getchar_unlocked() позволило 
сэкономить еще немного времени.

На моем компьютере, программа со входом 10М чисел, не превышающих по значению
10000 работает 0.5 секунды. 


Проверялось под Ubuntu:
> $ g++ --version

> g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3

И под OS X:
> $ g++ --version

> Apple LLVM version 7.0.0 (clang-700.1.76)
> Target: x86_64-apple-darwin15.6.0






